'''
  풀이
    n!을 해서 나온 값 중 끝에 0이 m개인 수가 있는지 구하는 문제이다.
    (어... 문제 이해를 못해 한참 헤매고 풀이 방법을 생각하다 또 헤매고...)
    예를 들어 m = 3이라고 할 때 n!값이 x000이 되는 수가 존재하면 참이고 존재하지 않으면 거짓이라는 뜻이다.
    
    그럼, 일단 0부터 n까지 모든 수의 펙토리얼 값을 구하며 0이 m개인 수를 찾는다고 가정해보자.
    이때 n의 범위가 어떻게 될 것인가?🤔 (이부분도 쉽게 생각하지 못했다...)
    풀이를 위해 생각했던 방식은 다음과 같다.
    
    먼저, 끝에 0이 오기 위해서는 어떤 수에 10의 배수를 곱해주면 된다.
    즉, 약수 2와 5를 1억개 포함하면 주어진 최대 m의 범위가 가능하다는 것이고,
    여기서 2는 모든 짝수에 포함되므로 생략하고 5를 기준으로 1억개 포함되는 범위가 어디까지인지 확인하면 된다.
    간단히 생각하면 5억까지 5의 배수가 1억개 존재하므로 5의 개수를 최소 1억개 보장한다.
    그럼 최대 n 범위를 5억으로 잡고 모든 경우를 구한다고 생각하면 완전탐색으론 제한 시간 내에 불가능하다는 결론이 나온다.
    
    따라서, n을 이분탐색의 대상으로 잡고 Parametric Search를 이용해 n값을 구했다.(편의상 최대 n의 범위를 10억으로 설정하였다.)
    중간 값에 대해 5의 개수 == m인지 확인하기 위해 다음과 같은 재귀함수를 사용하였다.
    대상 중간값을 5로 나눈 몫이 1보다 작을 때까지 5로 나눈 몫을 모두 더해주면 해당 수에서 5의 개수를 구할 수 있다.
    (해당 수를 5로 나눌 때마다 값이 1/5씩 줄어들기 때문에 충분히 제한 시간 내에 가능하다.)
'''

import sys
sys.setrecursionlimit(int(1e9))
input = lambda: sys.stdin.readline().strip()

def solution():
  answer = -1
  m = int(input())
  cnt = lambda x, y: cnt(x // 5, y + (x // 5)) if x >= 1 else y
  
  left, right = 0, int(1e9)
  while left <= right:
    mid = (left + right) // 2
    _check = cnt(mid, 0)
    if _check >= m:
      answer = mid if _check == m else answer
      right = mid - 1
    else:
      left = mid + 1
  
  print([-1, answer][answer != -1])

if __name__ == '__main__':
  solution()