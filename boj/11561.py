'''
  풀이
    구하고자 하는 것: 주어진 조건을 만족하면서 밟을 수 있는 징검다리 최대 수
    주어진 징검다리 수의 최대 범위: 1 ~ 10^16
    1) 징검다리 수의 범위를 볼 때 완전 탐색 불가능.
    2) 최대 밟을 수 있는 징검다리 수를 이분 탐색의 대상으로 잡고 parametric search를 적용
      1. 1 ~ 최대 징검다리 수(n)까지 범위에서 이분탐색을 수행
      2. 중간값에 대해 주어진 조건들을 만족하는지 확인
        징검다리를 밟는 수를 최대로 하려면 각 징검다리 간의 점프 "간격을 최소"로 해야한다.
        주어진 조건을 만족하면서 간격을 최소화하려면 처음에 점프 간격을 1로 시작하여 간격을 1씩 증가시켜나가면 된다.
        예를 들어 징검다리를 "m개 밟는 경우 1 + 2 + ... + m - 1 + m을 구해서 n값과 비교"하면 된다.
        문제에서 n번째 징검다리를 무조건 밟아야 한다는 조건이 있지만 1 ~ m의 합이 n을 초과하는지만 확인하면 된다.
        (그 이유는 1 ~ m의 합이 n보다 작은 경우는 마지막 점프하는 간격의 값을 n을 밟을 수 있도록 다른 값으로 치환해주면 되기 때문)
      3. 2에서 구한 징검다리 간격의 합과 n번째 징검다리까지의 간격(n)을 비교해 다음 과정을 반복 수행하며 밟을 수 있는 징검다리의 최대 수를 구한다.
        3-1. 징검다리 간격의 합 > n
          간격을 최소로 해도 현재 징검다리의 수만큼 밟을 수 없으므로 right = mid - 1로 밟을 수 있는 징검다리 수를 줄인다.
        3-2. 징검다리 간격의 합 <= n
          현재 징검다리의 수를 밟기 충분하므로 left = mid + 1로 밟을 수 있는 징검다리 수를 늘리고 현재 밟는 징검다리 수를 저장한다.
'''

import sys
input = lambda: sys.stdin.readline().strip()

def solution(n):
  answer = -1
  cnt = lambda x: (x ** 2 + x) // 2
  left, right = 1, n
  
  while left <= right:
    mid = (left + right) // 2
    if cnt(mid) > n:
      right = mid - 1
    else:
      left = mid + 1
      answer = mid
  print(answer)

if __name__ == '__main__':
  for i in range(int(input())):
    solution(int(input()))