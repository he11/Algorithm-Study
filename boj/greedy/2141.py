'''
  풀이
    먼저, 완전 탐색으로 풀 수 있을지 생각해보았다.
    주어진 n의 범위는 10만이고, 각 위치마다 우체국과 거리를 계산하여 비교한다면
    O(N^2)으로 약 100만의 연산이 필요하여 시간 초과라고 판단하였다.
    
    다음으로, 문제에 주어진 위치값이 상당히 크기 때문에 이진 탐색을 이용할 수도 있겠다고 생각했다.
    하지만, 비교 대상을 정확히 지정할 수가 없고 마을 위치와 사람의 수가 비례하는 형태가 아니기 때문에
    Parametric Search를 적용하기 어렵다고 판단하여 다른 방법을 생각했다.
    
    마지막으로, 투 포인터를 사용하여 풀 수 있었다.
    여기서, 우선 파악해야할 핵심 요소는 우체국의 위치를 기준으로 마을을 두 구간으로 나누었을 때
    두 구간에 속한 사람들의 수의 차가 0에 가까울 수록 최단 거리라는 것이다.
    즉, 전체 사람들의 수의 중간 값에 가까워지는 지점을 찾는 것이다.
    
    다음 예시를 통해 간단히 생각해보면
      1, 3, 8, 10, 11 이라는 위치가 주어졌을 때 각 위치 간 최단 거리를 만족하는 지점을 찾는다고 하면
    답은 5개의 위치 중 중간 값인 8이 된다.
    그 이유는 아주 간단히 생각할 수 있다. 중간 지점에서 어느 한쪽 방향으로 위치를 이동한다고 가정하면
    예를 들어 10으로 이동한다고 했을 때, 좌우측 각각 증감하는 거리를 따져보면
    좌측에는 3개의 위치가 2씩 증가하고 우측에는 10을 포함한 2개의 위치가 2씩 감소하므로 총 6 - 4 = 2만큼 거리가 증가한다.
    
    따라서, 사람의 수에 대해서도 위와 동일하게 생각하여 적용하면 된다.
    먼저, 마을 위치 기준으로 오름차 정렬한 후 투 포인터를 사용하기 위해 구간합을 구해주었다.
    그 다음, 각 마을의 위치를 순회하며
    해당 마을을 기준으로 양쪽에 있는 사람들 수의 차의 절댓값이 이전 값보다 작아질 때마다 우체국 위치를 갱신해주었다.
'''

import sys
input = lambda: sys.stdin.readline().strip()
INF = int(1e9)

def solution():
  n = int(input())
  town = [list(map(int, input().split())) for _ in range(n)]
  town.sort()

  people = [0]
  for _, i in town:
    people.append(people[-1] + i)

  answer = 0
  diff = INF
  for i, v in enumerate(town):
    dist = abs(people[i] - (people[n] - people[i + 1]))
    if dist < diff:
      diff = dist
      answer = v[0]

  print(answer)
  
if __name__ == '__main__':
  solution()