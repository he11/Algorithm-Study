'''
  풀이
    핵심 아이디어는 "무게 제한이 큰 크레인순으로 무게가 무거운 박스를 옮기는 것"이다.
    주어진 크레인과 박스를 내림차 순으로 정렬한 후
    만약, 가장 무거운 박스 > 무게 제한이 가장 큰 크레인이면 모든 박스를 옮길 방법이 없으므로 -1을 반환한다.
    그게 아니라면 박스를 모두 옮길 때까지 크레인을 순회하며 "크레인 >= 박스"를 만족하는 박스를 차례로 제거하고
    전체 크레인을 모두 순회할 때마다 시간을 1분씩 추가하면 된다.
    
    처음에는 boxes 리스트의 중간에서 값을 제거하면 데이터 이동이 발생해 효율이 좋지 않다고 생각했다.
    그래서, 현재 크레인이 옮길 수 없는 박스들은 스택에 저장했다가 다시 boxes 리스트에 합치는 방법을 사용했다.
    하지만, 이 방법의 경우 시간 초과는 발생하지 않았지만 처리 시간이 5,000ms이상 소모되었다.
    스택을 뒤집고 다시 boxes 리스트에 합치는 과정에서 많은 시간이 소모되었을 것이다.
    
    변경한 방법은 스택을 제거한 후 크레인마다 현재 남은 박스들을 순회하며
    "크레인 >= 박스"를 만족하는 박스를 boxes 리스트에서 제거하는 방법이다.
    이렇게 변경하니 매 크레인마다 남은 박스들을 순회하여 시간 초과가 발생했다.
      예를 들어, 50개의 크레인이 10,000개의 박스를 옮길 때 1개의 크레인만 박스를 옮길 수 있다고 가정하면
      대략 49 * 9,999 + 49 * 9,998 + ... 49 * 1 = 49 * (9,999 + ... + 1) = O(n * m^2)이 되기 때문에 시간 초과가 발생한다.
    그래서, 현재 크레인의 무게 제한과 가장 가벼운 박스의 무게를 비교하는 로직을 추가했고,
    해당 크레인으로 옮길 수 있는 박스가 없으면 이후 크레인 순회를 중단하고 다시 첫 번째 크레인부터 순회하도록 처리했다.
    그 결과, 처리 시간이 약 250ms로 처음 스택을 이용했던 풀이보다 약 20배정도 감소했다.
'''

import sys
input = lambda: sys.stdin.readline().strip()

def solution():
  n = int(input())
  cranes = sorted(map(int, input().split()), reverse=True)
  m = int(input())
  boxes = sorted(map(int, input().split()), reverse=True)
  
  if cranes[0] < boxes[0]:
    return -1

  time = 0
  while boxes:
    for crane in cranes:
      if boxes and crane < boxes[-1]:
        break
      for i, box in enumerate(boxes):
        if crane >= box:
          boxes.pop(i)
          break
    time += 1

  return time
  
if __name__ == '__main__':
  print(solution())
