'''
  풀이
    주어진 동전판의 마지막 칸부터 역순으로 뒷면인 동전들을 뒤집으면
    뒤집는 최소 횟수를 보장하는 그리디 알고리즘이다.
    
    m, n의 최대 범위가 100이므로 동전을 뒤집을 때마다 동전의 상태를 기록하게 되면
    대략 시간 복잡도가 n^2 * m^2이 되어 시간초과 우려가 있다.
    
    그래서, 처음에는 뒤집을 때의 규칙성을 찾기 위해 많은 시간을 소모했다.
    하지만 규칙성을 찾는데 실패했고, 동전 상태 기록을 최소화시킬 방법을 찾아 풀이했다.
    동전판의 열에 대해 각각 뒤집은 누적 횟수를 구하여 현재 위치의 동전 상태를 결정하는 방법이다.
    현재 위치의 동전에 대해 해당 경우를 나누어보면 다음과 같다.
      1. 현재 위치의 동전이 앞면일 때
          뒤집은 누적 횟수가 짝수 -> 앞면을 유지하므로 뒤집지 않는다.
          뒤집은 누적 횟수가 홀수 -> 뒷면이 되므로 뒤집는 횟수 1 추가
      2. 현재 위치의 동전이 뒷면일 때
          뒤집은 누적 횟수가 짝수 -> 뒷면이 되므로 뒤집는 횟수 1 추가
          뒤집은 누적 횟수가 홀수 -> 앞면이 되므로 뒤집지 않는다.
'''

def solution():
  n, m = map(int, input().split())
  coins = [input() for _ in range(n)]
  
  cnt = [0] * m
  for i in range(n - 1, -1, -1):
    for j in range(m - 1, -1, -1):
      cur = sum(cnt[j:])
      if coins[i][j] == '1':
        cnt[j] += [1, 0][cur & 1]
      else:
        cnt[j] += [0, 1][cur & 1]

  print(sum(cnt))
  
if __name__ == '__main__':
  solution()