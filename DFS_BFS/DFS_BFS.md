# 🔎 DFS & BFS 알고리즘

DFS(Depth First Search) 알고리즘은 "**깊이 우선 탐색**"이라 하며, 그래프의 깊은 노드부터 우선적으로 탐색하는 방법이다.<br>

BFS(Breath First Search) 알고리즘은 "**너비 우선 탐색**"이라 하며, 그래프의 인접한 노드부터 우선적으로 탐색하는 방법이다.

<br>

# 💡 DFS와 BFS의 동작 과정

<div align="center">
  <img class="graph_img" src="../img/graph.png" width="300px" height="200px">

출처: [이코테\_DFS_BFS by나동빈님](https://www.youtube.com/watch?v=PqzyFDUnbrY&list=PLRx0vPvlEmdBFBFOoK649FlEMouHISo8N&index=3)

</div>

> 방문한 노드를 재방문하지 않기 위해 방문 처리를 로직을 수행한다.

- [DFS](reference/dfs.py)

1. 탐색을 시작할 노드를 스택에 넣고 방문 처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 스택에 넣고 방문 처리하고, 없으면 스택의 최상단 노드를 꺼낸다.
3. 2번 과정을 더 이상 수행할 수 없을 때까지 반복한다.

- [BFS](reference/bfs.py)

1. 탐색을 시작할 노드를 큐에 넣고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드와 인접한 노드 중 방문하지 않은 노드를 모두 큐에 넣고 방문 처리 한다.
3. 2번 과정을 더 이상 수행할 수 없을 때까지 반복한다.

<br>

# 📌 문제 파악 포인트

> 문제를 풀며 생각해본 내용이므로 잘못된 부분에 대한 조언은 언제든지 환영합니다.😀

- 2차원 배열에서 인접한 좌표에 대해 탐색을 요구한다<br>
  - 단순 영역 탐색 == DFS, BFS
  - 이동 간 가중치가 일정한 최단 경로 탐색 == BFS

* 좀 더 문제를 접한 후 추가 예정...

<br>

# 📚 부록

> 위 알고리즘을 이해하기 위해 필요한 추가 정의를 알아보자.<br>

- 자료구조(Data Structure)란 연관성있는 데이터를 쉽게 관리하고 처리하기 위해 모아놓은 "**데이터 집합**"을 의미한다.<br>
- 탐색(Search)은 이러한 자료구조에서 "**원하는 데이터를 찾는 과정**"을 의미한다.<br>
- [스택(Stack)](reference/stack.py)이란 FILO(First In Last Out) 또는 LIFO(Last In First Out) 구조로 "**먼저 들어온 데이터가 가장 나중에 나가는**" 자료구조이다.<br>
  ex) 웹 사이트에서 뒤로가기를 통해 이전 페이지로 이동하는 경우<br>

* [큐(Queue)](reference/queue.py)란 FIFO(First In First Out) 또는 LILO(Last In Last Out) 구조로 "**먼저 들어온 데이터가 가장 먼저 나가는**" 자료구조이다.<br>
  ex) 운영체제에서 프로세스를 스케줄링하는 경우<br>
* 그래프(Graph)는 각 노드(Node) 또는 정점(Vertex)들이 간선(Edge)으로 연결된 자료구조이다.<br>
  ex) 리눅스 시스템의 디렉토리 구조
* 그래프는 크게 다음 2종류로 분류된다.<br>

- [인접 행렬(Adjacency Matrix)](reference/graph_matrix.py) : 2차원 배열로 그래프의 연결 관계를 표현

  <img src="../img/graph_matrix.png" width="150px" align="left">

  |       |  0  |  1   |  2   |
  | :---: | :-: | :--: | :--: |
  | **0** |  0  |  7   |  5   |
  | **1** |  7  |  0   | 무한 |
  | **2** |  5  | 무한 |  0   |

<br>

- [인접 리스트(Adjacency List)](reference/graph_list.py) : 리스트로 그래프의 연결 관계를 표현

  <img src="../img/graph_list.png" width="200px" align="left">

  |     노드     | 대상 노드와 가중치를 포함한 리스트 |
  | :----------: | :--------------------------------: |
  | **graph[0]** |          [(1, 7), (2, 5)]          |
  | **graph[1]** |              [(0, 7)]              |
  | **graph[2]** |              [(0, 5)]              |

<br>

> 위 그래프를 표현하는 두 방식의 차이를 메모리와 속도 측면에서 살펴보자!!😆<br>

1. 메모리 효율성 : 인접 행렬 < 인접 리스트<br>
2. 속도 : 인접 행렬 > 인접 리스트<br>

먼저, 메모리 측면에서는 인접 행렬은 각 노드마다 모든 노드의 정보를 저장하기 때문에 노드 수가 많아질수록 메모리 효율이 낮아진다. 반면 인접 리스트는 해당 노드에 연결된 노드의 정보만 저장하므로 인접 행렬에 비해 메모리 효율이 좋다.<br><br>
다음으로, 속도 측면에서는 인접 행렬은 인덱스를 통해 노드 간의 연결 정보를 바로 얻을 수 있어 속도가 빠르다. 반면 인접 리스트는 특정 노드와의 연결 정보를 얻기 위해 현재 노드에 연결된 모든 노드를 하나씩 확인해야 하므로 속도 측면에서 좋지 않다.

<br>

> 그럼 어떤 방식을 선택하는 것이 좋을까...?😅<br>

역시 주어진 상황에 알맞은 방식을 선택하는 것이 맞는 것 같다.<br>
가령, 특정 노드와 연결된 모든 인접 노드를 순회해야하는 상황이면 속도 측면에서 두 방식의 차이가 적으므로 메모리 효율이 우수한 인접 리스트가 인접 행렬보다 좋은 선택이 되는 것처럼...
