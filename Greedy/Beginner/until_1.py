# 어떤 수 N이 1이 될 때까지 다음 연산 중 하나를 반복적으로 선택해 수행한다.
#   1. N - 1
#   2. N / K (단, K로 나누어 떨어질 때만 선택 가능)
# N과 K가 주어질 때 1 또는 2 과정을 수행하는 최소 횟수? (항상 N >= K)

# 문제 파악 포인트:
#   1. 각 상황에 수행가능한 연산이 둘 이상이다
#   2. 항상 N >= K이므로 적어도 1번이상 2번 연산이 가능하고
#       조건을 만족할 시 최대한 많은 수를 줄이는 '2번 연산을 선택'해야 한다
#   3. 결과 값이 최소 횟수이다
#   따라서, 그리디 알고리즘을 적용해 해결할 수 있다

n, k = map(int, input().split())

count = 0
while n > 1:
    quotient, remainder = divmod(n, k)

    # 몫이 0이면 더 이상 나눌 수 없으므로 반복문 종료
    if quotient == 0:
        # 결과 값이 1이 되기 위해 나머지 - 1만큼 1번 연산을 수행해야 한다
        count += remainder - 1
        break;

    # K로 나누어 떨어지는 수까지 1번 연산을 수행하므로 1의 연산 횟수 'N % K'와
    # K로 나누어 떨어질 때 수행한 2번 연산 횟수 1을 더해준다
    count += remainder + 1
    n = quotient # 1, 2연산을 수행한 후 남은 몫으로 n값을 변경해준다.

print(count)